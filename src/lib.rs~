use std::env;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;
use std::sync::OnceLock;
use std::hash::{Hash, Hasher};
use std::collections::HashMap;
use std::process::{Command, Stdio};
use std::collections::hash_map::DefaultHasher;
use std::fs::{read_to_string, remove_file, File};

use luhtwin::at;
use luhtwin::Encase;
use luhtwin::Wrap;
use nix::unistd::Pid;
use nix::sys::signal::{kill, Signal};
use chrono::Local;

use luhcore::dirs::dev_temp_dir;
use luhlog::{error, info};
use luhtwin::{bail, LuhTwin};

pub static TMP_DIR: OnceLock<PathBuf> = OnceLock::new();

fn tmp_dir() -> &'static PathBuf {
    TMP_DIR.get_or_init(|| {
        if let Ok(p) = std::env::var("LUHPROC_TMP_DIR") {
            return PathBuf::from(p);
        }

        if cfg!(debug_assertions) {
            let mut d = dev_temp_dir();
            d.push("luhproc");
            return d 
        }

        let mut d = std::env::temp_dir();
        d.push("luhproc");
        d
    })
}

fn to_base36(num: u64) -> String {
    let mut n = num;
	let mut out = String::new();
	let alphabet = b"0123456789abcdefghijklmnopqrstuvwxyz";
	while n > 0 {
        out.push(alphabet[(n % 36) as usize] as char);
	    n /= 36;
	}

    if out.is_empty() {
        out.push('0');
	}

    out.chars().rev().collect()
}

pub type ChildWorkFn = fn() -> LuhTwin<()>;

#[derive(Debug, Clone)]
pub struct ChildTask {
    /// # THIS IS DYNAMIC *could change to whatever is identifying for you*
    pub id: String,
    pub env_var: &'static str,
    pub work: ChildWorkFn
}

// just here for delete all dirs
const PID_FILE_NAME: &str = "pid";

impl ChildTask {
    fn task_name_base(&self) -> String {
        self.env_var.to_lowercase().replace('_', "-")
    }

    fn task_name(&self) -> String {
        if self.id.is_empty() {
            panic!("task id must be set before calling task_name... task: '{}'", self.id);
        }

        let base_name = self.env_var.to_lowercase().replace('_', "-");

        let mut hasher = DefaultHasher::new();
        self.id.hash(&mut hasher);
        let h = hasher.finish();

        let hash_str = to_base36(h)[..12].to_string();

        return format!("{}-{}", base_name, hash_str)
    }

    fn set_id(&self, new_id: impl Into<String>) -> Self {
        let mut cloned = self.clone();
        cloned.id = new_id.into();
        return cloned
    }

    fn ensure_dirs(&self) -> LuhTwin<PathBuf> {
        let mut dir = tmp_dir().clone();
        dir.push(self.task_name());
        std::fs::create_dir_all(&dir)
            .wrap(|| "failed to create temp dir")?;
        Ok(dir)
    }

    fn get_log_file(&self) -> PathBuf {
        let mut path = self.ensure_dirs().unwrap();
        path.push("out.log");
        path
    }

    fn get_err_file(&self) -> PathBuf {
        let mut path = self.ensure_dirs().unwrap();
        path.push("err.log");
        path
    }

    fn get_pid_file(&self) -> PathBuf {
        let mut path = self.ensure_dirs().unwrap();
        path.push(PID_FILE_NAME);
        path
    }

    #[allow(dead_code)]
    fn remove_pid_file(&self) -> LuhTwin<()> {
        remove_file(self.get_pid_file().as_path())
            .wrap(|| "failed to remove pid file")?;

        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct ProcessManager {
    pub tasks: Vec<ChildTask>
}

impl ProcessManager {
    fn ensure_dir(p: &Path) -> LuhTwin<()> {
        if p.is_file() {
            bail!("expected dir but found file at {}", p.display());
        }
        if !p.exists() {
            std::fs::create_dir_all(p)?;
        }
        return Ok(())
    }

    pub fn new() -> LuhTwin<Self> {
        ProcessManager::ensure_dir(tmp_dir())
            .wrap(|| "ensure_dir failed")?;

        return Ok(Self { tasks: Vec::new() })
    }

    pub fn register_task(&mut self, env_var: &'static str, work: ChildWorkFn) {
        self.tasks.push(ChildTask { env_var, work, id: "".to_string() });
    }

    pub fn check(&self) -> LuhTwin<()> {
        for task in &self.tasks {
            if env::var(task.env_var).is_ok() {
                info!("{:-<58}", "");
                let now = Local::now();
                let time = now.format("%d/%m/%Y %H:%M").to_string();
                info!("Started background process '{}' at {}", task.env_var, time);
                info!("{:-<58}", "");
                (task.work)()?;
                std::process::exit(0);
            }
        }
        Ok(())
    }

    pub fn start(&self, task_name: &str, id: impl Into<String>, extra_env: Option<HashMap<String, String>>) -> LuhTwin<()> {
        let task = match self.tasks.iter().find(|t| t.env_var == task_name) {
            Some(t) => {
                Ok(t.set_id(id))
            },
            None => {
                return Err(at!("no registered task found with name '{}'", task_name).into())
            }
        }?;

        ChildTask::ensure_dirs(&task)
            .encase(|| format!("failed to create directories for task '{}'", task_name))?;

        if task.get_pid_file().as_path().exists() {
            return Err(at!("process is already running pid file at {}", task.get_pid_file().display()).into())
        }
        
        let exe = env::current_exe()
            .wrap(|| "failed to get the current exe path")?;
        
        let dout_file = File::create(task.get_log_file().as_path());
        let derr_file = File::create(task.get_err_file().as_path());
        
        if dout_file.is_err() || derr_file.is_err() {
            return Err("failed to create out and err files for child process...".into())
        }

        let mut cmd = Command::new(exe);

        cmd.env(task.env_var, task_name);

        if let Some(env_map) = extra_env {
            for (k, v) in env_map {
                cmd.env(k, v);
            }
        }
        
        let child = cmd 
            .stdin(Stdio::null())
            .stdout(dout_file.unwrap())
            .stderr(derr_file.unwrap())
            .spawn()
            .wrap(|| "failed to fork into the background")?;
        
        let mut pidfile = File::create(task.get_pid_file().as_path())
            .wrap(|| "failed to create the pid file use ps aux to shut the child process")?;
        
        write!(pidfile, "{}", child.id())
            .wrap(|| "failed to write to the pid file use ps aux to shut child process")?;
        
        info!("successfully started the background process '{}' with pid {}", task_name, child.id());
        Ok(())
    }

    fn find_task_dirs(&self, task: &ChildTask) -> LuhTwin<Vec<PathBuf>> {
        let mut dirs = Vec::new();
        let tmp = tmp_dir();

        if !tmp.exists() { return Ok(dirs); }
        for entry in std::fs::read_dir(tmp)? {
            let entry = entry?;
            if entry.file_type()?.is_dir() {
                let name = entry.file_name().to_string_lossy().to_string();
                if name.starts_with(&task.task_name_base()) {
                    dirs.push(entry.path());
                }
            }
        }
        Ok(dirs)
    }

    pub fn info(&self, task_name: &str, id: impl Into<String>) -> LuhTwin<String> {
        let task = match self.tasks.iter().find(|t| t.env_var == task_name) {
            Some(t) => Ok(t.set_id(id)),
            None => {
                return Err(at!("no registered task found with name '{}'", task_name).into())
            }
        }?;
        
        let task_dir = tmp_dir().join(task.task_name());
        
        if !task_dir.exists() {
            return Ok(format!("task '{}' (id: '{}') is not running", task_name, task.id));
        }
        
        let pid_file = task.get_pid_file();
        let pid: u32 = match read_to_string(&pid_file).ok().and_then(|s| s.trim().parse().ok()) {
            Some(p) => p,
            None => {
                return Ok(format!("task '{}' (id: '{}') has invalid pid file", task_name, task.id));
            }
        };
        
        let log_file = task.get_log_file();
        let err_file = task.get_err_file();
        
        let mut info = format!("task: {} (id: {})\n", task_name, task.id);
        info.push_str(&format!("pid: {}\n", pid));
        info.push_str(&format!("directory: {}\n", task_dir.display()));
        info.push_str(&format!("log file: {}\n", log_file.display()));
        info.push_str(&format!("error file: {}", err_file.display()));
        
        Ok(info)
    }

    pub fn stop(&self, task_name: &str, id: Option<impl Into<String> + Clone>) -> LuhTwin<()> {
        let task = match self.tasks.iter().find(|t| t.env_var == task_name) {
            Some(t) => {
                if id.is_some() {
                    Ok(t.set_id(id.clone().unwrap().into()))
                } else {
                    Ok(t.clone())
                }
            },
            None => {
                Err(anyerror!("no registered task found with name '{}'", task_name)
                    .severity(Level::Critical)
                    .build())
            }
        }?;

        if id.is_none() {
            let dirs = self.find_task_dirs(&task)
                .wrap(|| "failed to list task directories")?;

            if dirs.is_empty() {
                return Err(anyerror!("no running processes found for '{}'", task_name)
                    .severity(Level::Critical)
                    .build())
            }

            let mut errors = 0;
            for dir in dirs {
                let pid_file = dir.join(PID_FILE_NAME);
                if !pid_file.exists() {
                    continue;
                }

                let pid: u32 = match read_to_string(&pid_file).ok().and_then(|s| s.trim().parse().ok()) {
                    Some(p) => p,
                    None => {
                        error!("invalid pid file at {}", pid_file.display());
                        errors += 1;
                        continue;
                    }
                };

                if let Err(e) = kill(Pid::from_raw(pid as i32), Signal::SIGTERM) {
                    error!("failed to kill process {}: {}", pid, e);
                    errors += 1;
                } else {
                    info!("stopped process {} at {}", pid, dir.display());
                    let _ = std::fs::remove_dir_all(dir);
                }
            }

            if errors > 0 {
                Err(anyerror!("failed to stop some processes check the log for more details")
                    .build())
            } else { Ok(()) }
        } else {
            let task_dir = tmp_dir().join(task.task_name());
            if !task_dir.exists() {
                return Err(anyerror!("no running process found for '{}', id '{}'", task_name, task.id)
                    .severity(Level::Critical)
                    .build())
            }
            let pid: u32 = match read_to_string(task.get_pid_file()).ok().and_then(|s| s.trim().parse().ok()) {
                Some(p) => Ok(p),
                None => {
                    Err(anyerror!("invalid pid file at {}", task.get_pid_file().display())
                        .severity(Level::Critical)
                        .build())
                }
            }?;

            if let Err(e) = kill(Pid::from_raw(pid as i32), Signal::SIGTERM) {
                let _ = std::fs::remove_dir_all(task_dir);
                Err(anyerror!("failed to kill process {}: {}", pid, e)
                    .severity(Level::Critical)
                    .build())
            } else {
                info!("stopped process {} at {}", pid, task_dir.display());
                let _ = std::fs::remove_dir_all(task_dir);
                Ok(())
            }
        }
    }
}

#[macro_export]
macro_rules! process_manager {
    ( $( $env:expr => $func:expr ),* $(,)? ) => {{
        let mut pm = $crate::ProcessManager::new()?;
        $(
            pm.register_task($env, $func);
        )*
        Ok::<_, luhtwin::AnyError>(pm)
    }};
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    fn dummy_task() {}

    #[test]
    fn test_task_name_generation() {
        let task = ChildTask {
            id: "myid123".to_string(),
            env_var: "MY_TASK",
            work: dummy_task,
        };

        let base = task.task_name_base();
        assert_eq!(base, "my-task");

        let full_name = task.task_name();
        assert!(full_name.starts_with("my-task-"));
        assert_eq!(full_name.len(), "my-task-".len() + 12);
    }

    #[test]
    fn test_set_id_returns_new_task() {
        let task = ChildTask {
            id: "".to_string(),
            env_var: "MY_TASK",
            work: dummy_task,
        };

        let new_task = task.set_id("abc123");
        assert_eq!(new_task.id, "abc123");
        assert_eq!(task.id, "");
    }

    #[test]
    fn test_ensure_dirs_creates_directory() {
        let task = ChildTask {
            id: "testid".to_string(),
            env_var: "MY_TASK",
            work: dummy_task,
        };

        let dir = task.ensure_dirs().unwrap();
        assert!(dir.exists());
        assert!(dir.is_dir());

        fs::remove_dir_all(dir).unwrap();
    }

    #[test]
    fn test_get_log_and_err_files() {
        let task = ChildTask {
            id: "testid".to_string(),
            env_var: "MY_TASK",
            work: dummy_task,
        };

        let log_file = task.get_log_file();
        let err_file = task.get_err_file();

        assert!(log_file.parent().unwrap().exists());
        assert!(err_file.parent().unwrap().exists());

        assert!(!log_file.exists());
        assert!(!err_file.exists());

        fs::remove_dir_all(log_file.parent().unwrap()).unwrap();
    }

    #[test]
    fn test_process_manager_register_and_find_task() {
        let mut pm = ProcessManager::new().unwrap();
        pm.register_task("TEST_ENV", dummy_task);

        assert_eq!(pm.tasks.len(), 1);
        assert_eq!(pm.tasks[0].env_var, "TEST_ENV");
    }

    #[test]
    fn test_task_name_dirs_matching() {
        let mut pm = ProcessManager::new().unwrap();
        pm.register_task("TEST_ENV", dummy_task);

        let task = pm.tasks[0].set_id("123");
        let dir = task.ensure_dirs().unwrap();

        let dirs = pm.find_task_dirs(&task).unwrap();
        assert!(dirs.iter().any(|d| d == &dir));

        fs::remove_dir_all(dir).unwrap();
    }
}
